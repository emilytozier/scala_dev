//Напишите функцию, которая принимает три аргумента (String, Int, Double) и объединяет их в одну строку через пробел.
// Затем преобразуйте эту функцию в каррированную версию, которая принимает первый аргумент и возвращает функцию, принимающую
// оставшиеся два аргумента
object HOF1 extends App { //

  def first(s: String) = (y: Int, z: Double) => s + " " + y + " " + z

  println(first("string")(4, 6.0))


}


//Напишите функцию, которая принимает список функций и значение, а затем возвращает список результатов применения каждой функции к этому значению.
object HOF2 extends App {

    val f = (x: Int) => x + 34
    val g = (x: Int) => x * 2
    val l = List(f, g)

    def h21(a: Int, l: List[Int => Int]): List[Int] = {
      for (i <- l) yield i(a)
    }

    println(h21(21, l))


}

//Напишите функцию, которая принимает другую функцию двух аргументов и возвращает каррированную версию этой функции
// ( т.е. функцию, которая принимает первый аргумент и возвращает функцию, принимающую второй аргумент)
object HOF3 extends App {
  def plus(a: Int)(b: Int) = a + b

  def plus2 = plus(2)(_)

  println(plus2(4))
}

//Напишите функцию высшего порядка, которая принимает список функций и возвращает новую функцию, которая применяет каждую функцию из списка к результату предыдущей функции. Например, если дан список функций List((x: Int) => x + 1, ( x: Int) => x * 2), то результирующая функция должна выполнять следующее: f(x) = (x + 1) * 2
object HOF4 extends App {

  val f = (x: Int) => x + 1
  val g = (x: Int) => x * 2
  val l = List(f, g)

  def h2(l: List[Int => Int]): Int => Int = {
    l.foldLeft((i: Int) => i) { case (acc, e) =>
      (i: Int) => e(acc(i))
      // (i: Int) => i
      // ((i: Int) => i) + 1
      // (((i: Int) => i) + 1) * 2
      // (i + 1) * 2
    }
  }
 // List.empty[Int].map(_ + 1) // List(...)
 // List.empty[Int].foldLeft(0) { case (acc, e) => acc + e + 2 } // 0 + List(...).sum + List(...).size * 2
 //инициация функции f1 проходит через вызов метода h2 с переданным ему листом
  val f1: Int => Int = h2(l)
  //так это выглядит как функция с переданным аргументом
  println(f1(3)) //
  //так тоже работает, здесь не создаем промежуточную ф-ю, а сразу вызывыаем метод с переданным аргуметом
  println(h2(l)(3)) //
 // в принципе и так работает, но не оч.читабельно
  println(h2(List((x: Int) => x + 1, ( x: Int) => x * 2))(3)) //
}
