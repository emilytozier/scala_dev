//Напишите функцию, которая принимает три аргумента (String, Int, Double) и объединяет их в одну строку через пробел.
// Затем преобразуйте эту функцию в каррированную версию, которая принимает первый аргумент и возвращает функцию, принимающую
// оставшиеся два аргумента
object HOF1  extends App{//

  def first(s: String) = (y: Int, z: Double) => s + " "+ y +" "+ z
  println(first("string")(4, 6.0))


}
//не доделан
//Напишите функцию, которая принимает список функций и значение, а затем возвращает список результатов применения каждой функции к этому значению.
object HOF2 extends App{
  //  val toPowerOfTwo = (x: Int) => x * x
  //  val toPowerOfThree = (x: Int) => x * x * x
  //
  //  def toPower(x: Int, f: List [Int => Int]): Int = x => f(x))
  //
  //  println(toPower(2, List[toPowerOfTwo, toPowerOfThree]))


}

//Напишите функцию, которая принимает другую функцию двух аргументов и возвращает каррированную версию этой функции
// ( т.е. функцию, которая принимает первый аргумент и возвращает функцию, принимающую второй аргумент)
object HOF3 extends App{
  def plus(a: Int)(b: Int) = a + b
  def plus2 = plus(2)(_)

  println(plus2(4))
}
//не доделан Напишите функцию высшего порядка, которая принимает список функций и возвращает новую функцию, которая применяет каждую функцию из списка к результату предыдущей функции. Например, если дан список функций List((x: Int) => x + 1, ( x: Int) => x * 2), то результирующая функция должна выполнять следующее: f(x) = (x + 1) * 2
object HOF4 extends App{
  //  def addition(List [a: (Int) => Int, b: (Int) => Int]): Int = f(a) + f(b)
  //  val squareSum = (x: Int) => Int
  //  val cubeSum = (x: Int) => Int
  //
  //
  //
  //  println(addition(List((x: Int) => x + 1, (x: Int) => x * 2)))
}